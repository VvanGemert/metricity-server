#!/usr/bin/env ruby
$LOAD_PATH << File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'rubygems'
require 'metricity-server'
require 'thin'

@pid_file = '/tmp/metricitiy-server.pid'

def start_app(args)
  if args.empty?
    puts 'Metricity Help'
  else
    if [:start, :run, :stop].include? args.first.to_sym
      send(args.first.to_sym)
    end
  end
end

def run
  puts "Metricity Server " + Metricity::Server::VERSION
  Thin::Logging.silent = true
  server = Thin::Server.new('0.0.0.0', 4567) do
    EM.next_tick {
      Signal.trap('QUIT') { EM.stop }
      EM.open_datagram_socket '127.0.0.1', 9888, Metricity::Server::Receiver
    }
    map '/' do
      puts ":: Webserver started.."
      run Metricity::Server::Webserver
    end
  end

  server.pid_file = @pid_file
  server.start
end

def get_pid
	if File.exists?(@pid_file)
		file = File.new(@pid_file, "r")
		pid = file.read
		file.close
		pid
	else
		0
	end
end

def start
  pid = get_pid
  if pid != 0
    warn 'Metricity Server is already running'
    exit -1
  end
  
  pid = fork { run }

  begin
  	file = File.new(@pid_file, "w")
    file.write(pid)
    file.close
    Process.detach(pid)
  rescue => exc
    Process.kill('TERM', pid)
  	warn "Cannot start daemon: #{exc.message}"
  end
end

def stop
	pid = get_pid
	if pid != 0
	  # Gracefully shutdown
		Process.kill('QUIT', pid.to_i)
		File.delete(@pid_file)
		puts ':: Stopping Metricity Server'
	else
		warn 'No Daemon was running'
	end
end

start_app(ARGV)
