#!/usr/bin/env ruby
$LOAD_PATH << File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))

require 'metricity_server'
require 'thin'

@pid_file = '/tmp/metricitiy-server.pid'

def start_app(args)
  if args.empty?
    puts 'Metricity Help'
  else
    send(args.first.to_sym) \
      if [:start, :run, :stop, :status].include? args.first.to_sym
  end
end

def run
  puts 'Metricity Server ' + Metricity::Server::VERSION

  server = setup_server
  server.pid_file = @pid_file
  server.start
end

def setup_server
  Thin::Logging.silent = true
  Thin::Server.new('0.0.0.0', 4567) do
    EM.next_tick do
      EM.open_datagram_socket '127.0.0.1', 9888, Metricity::Server::Receiver
    end
    map '/' do
      puts ':: Webserver started..'
      run Metricity::Server::Webserver
    end
  end
end

def load_pid
  if File.exist?(@pid_file)
    file = File.new(@pid_file, 'r')
    pid = file.read
    file.close
    pid
  else
    0
  end
end

def check_pid(pid)
  if pid != 0
    warn 'Metricity Server is already running'
    exit
  end
end

def detach_process(pid)
  file = File.new(@pid_file, 'w')
  file.write(pid)
  file.close
  Process.detach(pid)
  rescue => exc
    Process.kill('TERM', pid)
    warn "Cannot start daemon: #{exc.message}"
end

def start
  pid = load_pid
  check_pid(pid)
  pid = fork { run }
  detach_process(pid)
end

def stop
  pid = load_pid
  if pid != 0
    # Gracefully shutdown
    Process.kill('QUIT', pid.to_i)
    File.delete(@pid_file)
    puts ':: Stopping Metricity Server'
  else
    warn 'No Daemon was running'
  end
end

def status
  pid = load_pid
  if pid != 0
    puts ':: Metricity Server is running'
  else
    puts ':: Metricity Server is not running'
  end
end

start_app(ARGV)
